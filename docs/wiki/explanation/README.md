# Explanation（解説）

**理解指向** - Manganize の設計思想と背景を理解するためのドキュメントです。

Explanation は、「なぜそうなっているのか」を説明します。技術的な決定の背景、アーキテクチャの設計原則、トレードオフの考察などを深く掘り下げます。

## 🧠 利用可能な解説

### アーキテクチャ解説

[アーキテクチャ解説 →](architecture.md)

**内容**:

#### システム概要
- 全体のアーキテクチャ図
- 技術スタックの構成

#### コアコンポーネント
- **ManganizeAgent**: エージェント層の責務と設計
- **ツール層**: ツールの役割と実装パターン
- **プロンプト層**: プロンプトの構造と設計思想

#### データフロー
- 基本的な実行フロー
- 会話履歴の管理

#### 設計パターン
- ツールパターン
- 状態更新パターン
- チェックポイントパターン

#### スケーラビリティの考慮
- 現在のアーキテクチャの制限
- 改善案（永続化、非同期、キューイング）

#### セキュリティの考慮
- API キーの管理
- 入力の検証
- レート制限

#### テスタビリティ
- ユニットテスト
- 統合テスト
- モックの活用

---

### 設計の意思決定

[設計の意思決定 →](design-decisions.md)

**内容**:

主要な技術選定とその背景を説明します。

1. **LangGraph の採用**
   - 検討した選択肢
   - 採用理由とトレードオフ
   - 代替案との比較

2. **Gemini 3 Pro Image Preview の選択**
   - 他の画像生成モデルとの比較
   - 採用理由

3. **プロンプト設計**
   - 構造化されたプロンプトの採用理由
   - プロンプトエンジニアリングの原則

4. **型ヒントの徹底**
   - なぜ型ヒントを必須にしたか
   - 効果とトレードオフ

5. **uv によるパッケージ管理**
   - pip、Poetry との比較
   - 採用理由

6. **チェックポインターの選択**
   - InMemorySaver を選んだ理由
   - 本番環境での推奨

7. **ディレクトリ構造**
   - フラットで最小限の構造を選んだ理由
   - 将来の拡張戦略

8. **エラーハンドリング戦略**
   - Command でエラーを返す理由

9. **テスト戦略**
   - 段階的なテストの導入

各決定について、以下の観点で説明しています。

- **検討した選択肢**: 何を比較したか
- **採用理由**: なぜこの選択をしたか
- **トレードオフ**: 何を得て、何を失ったか
- **代替案との比較**: 他の選択肢との違い

---

### プロンプトエンジニアリング解説

[プロンプトエンジニアリング解説 →](prompt-engineering.md)

**内容**:

#### プロンプトの役割
- プロンプトが果たす機能
- 良いプロンプトの条件

#### Manganize のプロンプト構造
- 全体構造の説明
- 各セクションの詳細解説
  - Role（役割定義）
  - Character Reference（キャラクター仕様）
  - Art Style & Layout（スタイルと構成）
  - Negative Constraints（禁止事項）
  - Content / Story（コンテンツ）

#### プロンプトエンジニアリングの原則
1. 具体性（Specificity）
2. 構造化（Structure）
3. 制約の明示（Constraints）
4. 例の提供（Examples）
5. 反復改善（Iteration）

#### プロンプトのデバッグ
- よくある問題と解決策

#### プロンプトのバリエーション
- スタイルを変更する例
- 構成を変更する例

#### プロンプトのテスト
- A/B テスト
- バリエーションテスト

---

## 解説の読み方

### 1. 「なぜ？」を理解したいとき

```
疑問: なぜ LangGraph を使っているのか？
  ↓
設計の意思決定 → LangGraph の採用
  ↓
背景と理由、代替案との比較を読む
```

### 2. システム全体を理解したいとき

```
目的: システムの全体像を把握したい
  ↓
アーキテクチャ解説を最初から読む
  ↓
コアコンポーネント、データフロー、設計パターンを理解
```

### 3. 特定の技術を深く理解したいとき

```
興味: プロンプトの設計について詳しく知りたい
  ↓
プロンプトエンジニアリング解説
  ↓
原則、手法、実例を学ぶ
```

## Explanation とその他のドキュメントの関係

```
Tutorial（チュートリアル）
  ↓ 「どうやるか」を学ぶ

How-to（ハウツーガイド）
  ↓ 「どう解決するか」を学ぶ

Reference（リファレンス）
  ↓ 「何ができるか」を確認する

Explanation（解説） ← あなたはここ
  ↓ 「なぜそうなのか」を理解する
```

## なぜ Explanation が重要か

### 1. 保守性の向上

設計の背景を理解していると、将来の変更時に以下が可能になります。

- **適切な判断**: 元の意図に沿った変更ができる
- **トレードオフの理解**: 何を犠牲にしているか把握できる
- **代替案の検討**: 他の選択肢を再評価できる

### 2. 学習の促進

単に「やり方」を知るだけでなく、「理由」を理解することで：

- **応用力**: 似た問題に自分で対処できる
- **批判的思考**: 設計の良し悪しを判断できる
- **創造性**: 新しいアイデアを生み出せる

### 3. コミュニケーションの改善

設計の意図を共有することで：

- **議論の質**: 技術的な議論が深まる
- **合意形成**: チーム内で方針を共有できる
- **ドキュメント**: 知識が蓄積される

## 読む順序

初めて Explanation を読む方は、以下の順序をお勧めします。

```
1. アーキテクチャ解説
   ↓ システム全体の構造を理解

2. 設計の意思決定
   ↓ 主要な技術選定の背景を知る

3. プロンプトエンジニアリング解説
   ↓ プロンプト設計の原則を学ぶ
```

## 関連ドキュメント

### 実践的な学習

- [はじめての Manganize](../tutorials/getting-started.md) - 基本的な使い方
- [LangGraph を理解する](../tutorials/understanding-langgraph.md) - LangGraph の基礎

### 問題解決

- [プロンプトをカスタマイズする](../how-to/customize-prompt.md) - プロンプトの編集
- [カスタムツールを追加する](../how-to/add-custom-tool.md) - ツールの追加
- [画像品質を最適化する](../how-to/optimize-image-quality.md) - 画質の向上

### 詳細な仕様

- [API リファレンス](../reference/api.md) - API の詳細仕様
- [設定リファレンス](../reference/configuration.md) - 設定ファイルの詳細

## フィードバック

解説に関するフィードバックや質問は、GitHub の Issue でお願いします。

- もっと詳しく知りたいトピック
- わかりにくい説明
- 追加してほしい解説

## 貢献

新しい解説の追加や既存解説の改善は、GitHub の Pull Request でお願いします。

特に以下のような貢献を歓迎します。

- 設計の背景や意図の記録
- トレードオフの分析
- アーキテクチャパターンの説明
- プロンプトエンジニアリングの手法

## 今後追加予定の解説

- **LLM の選択と評価**
  - なぜ Gemini を選んだか、他のモデルとの比較

- **パフォーマンス最適化の戦略**
  - キャッシング、バッチ処理、並列化の考慮

- **コスト最適化の考慮**
  - API コストの削減戦略

- **マルチモーダル AI の活用**
  - テキストと画像の統合的な扱い方

